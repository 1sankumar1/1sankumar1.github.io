<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Enterprise Legacy and REST</title>
<meta name="description" content="                  One common challenge that enterprises are facing today is “How to RESTi-fy their decade old legacy applications”. Before we get into “How” ...">

<link rel="stylesheet" href="/css/main.css">
<link rel="canonical" href="http://localhost:4000/blog/2016/why-how-rest-enterprise/">
<link rel="alternate" type="application/rss+xml" title="Sanjeev Kumar" href="http://localhost:4000/feed.xml" />

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96036264-1', 'auto');
  ga('send', 'pageview');
</script>


</head>
<body>
  <header class="site-header">
  <div class="container">
    <input type="checkbox" id="toggleNavbar">
    <h1 class="logo"><a href="/">san<span>kumar</span></a></h1>
    <label for="toggleNavbar" role="button" class="toggle-navbar-button">
      <i class="icon icon-menu"></i>
      <i class="icon icon-cross"></i>
    </label>
    <nav class="navbar">
      <ul>
        <li><a href="/" title="Home">Home</a></li>
        
          <li><a href="/about" title="About">About</a></li>
        
          <li><a href="/blog" title="Blog">Blog</a></li>
        
        <li><a href="/feed.xml" target="_blank"><i class="icon icon-rss"></i></a></li>
      </ul>
    </nav>
  </div>
</header>


<main class="main-container">
  <div class="container">
    <article role="article" class="post">

  <div class="card">
    <header class="post-header">
      <h1 class="post-title">Enterprise Legacy and REST</h1>
      <em class="post-meta">
        <time>Mar 16, 2016</time>
      </em>
    </header>

    <div class="post-content">
        
      <div class="post-content">
      
      <div class="post-content">
      <p>One common challenge that enterprises are facing today is “How to RESTi-fy their decade old legacy applications”. Before we get into “How” part of RESTifying enterprise legacy, it is important to first understand the “Why”. What is wrong with SOAP web services? What actually changed in recent years, that we need to rethink now? After all, web services have abstracted enterprise legacy for more than a decade now.</p>

<p>Following are few broad areas that we need to understand why REST is more prominent than ever.</p>

<h4 id="1-rest-as-an-architectural-style-makes-more-sense-in-certain-situations">1) REST as an Architectural Style Makes More Sense in Certain Situations</h4>

<p>We tend to compare REST with SOAP web services but there cannot be a direct comparison between an architectural style (REST) and a protocol (SOAP). SOA with SOAP/HTTP and ROA (resource-oriented architecture) with JSON/HTTP have become so prominent forms of these two architectural styles that we mix these terms up. More apt comparison is between SOA and ROA. I have, though, used JSON and SOAP to examplify scenerios in the remaining post.</p>

<p>With that distinction in mind, let us start with SOA based web services. Web services are a way to do RPC. In simple terms, what RPC means is that if you cut open the SOAP request message, it has operation name inside it. Remember that “P” in RPC stands for “procedure” that you intend to call remotely - using web services, CORBA or any other means. This operation-oriented nature has problems in certain situations. It assumes that there exists a predefined operation, which behaves in certain way. Provider creates the contract and consumer adheres to that contract. This rigidity in contract though has benefits, is not always needed. Rigidity demands more governance and complicates the usage of services beyond enterprise boundaries. This behavior, to large extent, is dictated by SOA principles. Discoverability, service contracts, abstractions etc are, afterall, core to SOA. It does not mean that REST based architecture gives us the freedom to do things the way we want. It too has design principles and “constraints”. However, there are certain differences:</p>

<ul>
  <li>Both approaches decompose the problem domain differently. REST breaks down the problem as <em>resources</em>, where as SOA puts <em>actions</em> on the front seat.</li>
  <li>For most practical purposes, REST sits atop HTTP, whereas SOA based web services have one extra layer of abstraction in addition to HTTP - SOAP. Do we really need it, is highly debatable. It does have merits but those may not be needed in every situation.</li>
  <li>In case of REST, both “Web applications” and “Services” are designed with same architecture. It leverages standard elements of internet (routers, proxies, servers or consumer platforms) to their full potential, without any customizations.</li>
</ul>

<p>Irrespective of which architectural style we use, we need to make right engineering compromises and adhere to the guidance to the extent needed. What is more important is to understand the rationale, and make wise use of guidance, stated principles and imposed constraints for architectural style chosen.</p>

<p>NOTE: There do <a href="http://www.ibm.com/developerworks/library/ws-whichwsdl/">exists</a> message-oriented style for web services (Example: document/literal wrapped) but that too have constraints in addition to the complexity it brings.</p>

<h4 id="2-advent-of-digital-technology">2) Advent of Digital Technology</h4>

<p>Usage of REST has increased manifold due to emerging digital technologies. Let us take example of lowest denominator of digital channels – a modern web browser. It is not long since the job of a browser was primarily to render html markup. Of-course browsers were interactive right from the early days but most of the interactive-ness was handled on the web server. Browser mostly displayed content and captured the input. Web servers called the middleware, which in turn abstracted various enterprise systems. Things changed as commodity hardware became cheaper and powerful. It allowed desktop applications including browsers to consume more hardware and network resources. JS based frameworks, libraries and developer ecosystem leapfrogged the web development. Browser became full-blown client tier that now could provide rich user interface and also invoke enterprise resources directly.</p>

<p>With these advancements, REST based services made much more sense than the SOAP services. Roy Fielding’s REST architectural style that was envisioned for World Wide Web became more relevant to manage both html templates as well as the data to fill those templates.</p>

<p>Extend this to mobile and other devices that have built in support for JSON, it makes perfect sense to use REST based architecture that provides uniform access to channels – existing or new.</p>

<h4 id="3-web-apis-is-a-channel-strategy">3) Web APIs is a Channel Strategy</h4>

<p>It is important to note that REST based web APIs are mostly part of <em>channel strategy</em> whereas SOA has traditionally been used for <em>enterprise integration</em>. Yes, APIs can be used to wire enterprise applications, or web services can be exposed for digital channels but there is fundamental difference between the two. Channels typically require data to be mashed together which is easier if based on <em>resources</em> than on <em>verb</em>-based services.</p>

<p>Also, APIs are about openness and innovation beyond enterprise boundaries. This require lean-ness in governance, ease of discoverability and so on. The way we have been governing web services, cannot meet that expectation.</p>

<h4 id="4-performance-and-scalability">4) Performance and Scalability</h4>
<p>Verboseness of XML increases consumption of computational and network resources. This become more important when applications are chattier. Chattiness is the very nature of the digital applications where user experience takes the centerstage. We need smaller payloads but with more network communication. Also, REST uses “GET” heavily (and SOAP does not) which is HTTP cacheable. Other aspect around performance that is usually discussed is stateless-ness of REST. In my opinion, SOAP services too are (or can be) stateless which makes this argument a little weaker. The only difference is that statelessness is <em>explicitly</em> avoided by REST.</p>

<h2>Having established when and why REST is advantageous, let us see how this can be implemented in enterprises.</h2>
<p>There are two situations are typically encountered in organizations.</p>

<ul>
  <li>Ground up development of application</li>
  <li>Legacy systems that need to be exposed for digital consumption</li>
</ul>

<p>Let us discuss these two cases in detail.</p>

<h4 id="ground-up-development">Ground-up Development:</h4>

<p>This is most straightforward and top-down scenerio where services can be designed RESTful ground up. We define the API spec first and then create the implementation. How we design REST APIs is not scope of this post but I like <a href="https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling">this</a> and <a href="http://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">this</a> as starting point. Three fundamental rules in my experience, are i) APIs are not mere CRUD operations over HTTP. ii) Granularity of API is contextual to the problem domain. iii) It is okay to convert some “Verbs” as “Nouns” as long as we have enterprise-wide formal guidance that describes where to draw the line.</p>

<h4>Legacy systems that need to be exposed to digital consumption:</h4>

<p>In large enterprises, there are tons of legacy applications (e.g. mainframes based, client server or fifteen years old java based applications) that are core to the business. Re-engineering these applications just for RESTification is not always business justifiable. Digital initiatives, however, do provide opportunities to piggy-back the RESTification exercise. It is important to note that digital platforms by themselves do not necessitate usage of REST architecture. There is affinity towards JSON based payloads which can be achieved without REST. In fact, organizations in last few years have chosen to create JSON service wrappers (over existing web services etc) to meet needs of mobile and other RIA platforms.</p>

<p>Assuming that benefits of REST usage are well justfied (some discussed above), following is an approach that can be considered. Here, I also like to mention <a href="https://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a> for REST strategy. In my opinion, in large enterprises it can take years to jump from one maturity level to the next as prescribed in this (or my understanding of it..). It may be more beneficial to seggregate API layer from the underlying systems as described below (in progress).</p>

<p><em>Step-1:</em> Identify the resources from the legacy systems. These could be extracted from existing documentation or code. It is comparatively easy to identify resources from applications that are built on object-oriented design. Besides resource identification, we need to determine the relationship among the resources.</p>

<p><em>Step-2:</em> Once we have identify the resources, next comes the ownership. Though resource identification and their ownership can go hand in hand, It is  important to understand that just because a resource is found in an LOB application, does not mean it belongs there(Example: A “Customer” resource in a multi-LOB organization). And vice versa. In addition, there can be resource hierarchy that needs to be established.</p>

<p>This leads to discussion on where we start with REST in organizations. In an ideal situation, it should enterprise wide initiative. At the bare minimum, the guidance and enterprise-wide governace aspects must be chalked out upfront.</p>

<p><em>Step-3:</em> For the identified resources, we now need to map existing service operations to HTTP verbs. This is the most complex part of this exercise. We may end up creating new resources or “blend resources” in the process.</p>

<p><em>Step-4:</em> Formalize the API specification. While performing above three steps, we are essentially modelling our APIs from the existing implementation in a bottom-up way. Extracting a formal definition of API is needed so that it can be shared with the API consumers.</p>

<p><em>Step-5:</em> Once we have the API specification with resources and verbs defined, next comes the implementation of API layer. API implementation in this case merely means to create layer that expose an endpoint as per the API spec and wire it with existing underlying resources. Commercial API Lifecycle management suites can ease this work. Most of these products also support industry specifications for APIs, provided lifecycle management services and add other digital capabilities. It however is not necessary to use any commerical tool to wire API layer with enterprise legacy resources. Whether to use one or create a custom API layer will be discussed in another post.</p>

<p>Feel free to comment.</p>

    </div>

    </div>

    </div>

    
<hr>

<aside id="comments" class="disqus">
  <h3><i class="icon icon-comments-o"></i> Comments</h3>
  <div id="disqus_thread"></div>
  <script>
    var disqus_config = function() {
      this.page.url = 'http://localhost:4000/blog/2016/why-how-rest-enterprise/';
      this.page.identifier = '/blog/2016/why-how-rest-enterprise';
    };
    (function() {
      var d = document,
      s = d.createElement('script');
      s.src = '//san4kumar.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</aside>


  </div>

</article>

  </div>
</main>

<footer class="site-footer">
  <div class="container">
    <ul class="social">
  <li><a href="https://github.com/1sankumar1" target="_blank"><i class="icon icon-github"></i></a></li>
  <li><a href="https://twitter.com/san_kumar" target="_blank"><i class="icon icon-twitter"></i></a></li>
  <li><a href="https://www.linkedin.com/in/sanjeev-kumar-77956a7" target="_blank"><i class="icon icon-linkedin"></i></a></li>
</ul>
    <p class="txt-medium-gray">
      <small>&copy;2023 Sanjeev Kumar. Made with <a href="http://jekyllrb.com/" target="_blank">Jekyll </a></small>
      <small>| Served by <a href="https://pages.github.com/" target="_blank"> Github Pages </a> | Themed by Made with <a href="https://github.com/nandomoreirame/end2end" target="_blank">Fernando</a></small>
    </p>
  </div>
</footer>


</body>
</html>
